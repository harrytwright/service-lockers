/**
 * This to automatically create the interface files with `Selectable`, `Insertable`, and `Updateable`
 * wrapping, mainly since it's an extra step I have to do, might as well make the code do it for me
 *
 * lol
 *
 * Completed: Maybe create the JSON* interfaces next from an openapi schema
 * Todo: Clean this up a lot
 * */

const path = require('path')
const fs = require('fs/promises')

const banner = `
/* eslint-disable */

/**
 * This file was automatically generated by @lanelink/tools
 *
 * Using \`json-schema-to-typescript\`, \`@redocly/openapi-core\` and \`prisma-kysely\`.
 *
 * DO NOT MODIFY IT BY HAND. Instead, modify the openapi schemas or the \`prisma.schema\`
 * and re-run \`@lanelink/tools generate\` to regenerate this file
 * */
 `

async function main() {
  try {
    await handleDatabaseSchema(
      path.join(process.cwd(), './src/datastore/kysely.database.types.ts')
    )

    await handleAPISchema(path.join(process.cwd(), './openapi/schema'))
  } catch (err) {
    console.error(err)
    return Promise.reject(err)
  }
}

main()
  .then((files) => {
    console.log('Completed with %s exit', 0)
  })
  .catch((err) => {
    console.error(err)
    process.exit(1)
  })

async function handleDatabaseSchema(file) {
  const ts = require('typescript')

  // Build a program using the set of root file names in fileNames
  let program = ts.createProgram([file], {
    target: ts.ScriptTarget.ES5,
    module: ts.ModuleKind.CommonJS,
  })

  const types = []

  // Visit every sourceFile in the program
  for (const sourceFile of program.getSourceFiles()) {
    if (!sourceFile.isDeclarationFile) {
      // Walk the tree to search for classes
      ts.forEachChild(sourceFile, visit)
    }
  }

  const dir = path.join(process.cwd(), './src/interfaces/database')
  try {
    await fs.mkdir(dir)
  } catch (err) {
    await fs.rm(dir, { force: true, recursive: true })
    await fs.mkdir(dir, { recursive: true })
  }

  for (const type of types) {
    const file = ts.createSourceFile(
      path.join(dir, `${type.replaceAll('_', '-')}.interface.ts`),
      '',
      ts.ScriptTarget.ESNext,
      false,
      ts.ScriptKind.TS
    )
    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })

    const source = ts.factory.createSourceFile(
      [
        ts.factory.createImportDeclaration(
          undefined,
          ts.factory.createImportClause(
            false,
            undefined,
            ts.factory.createNamedImports([
              ts.factory.createImportSpecifier(
                false,
                undefined,
                ts.factory.createIdentifier('Selectable')
              ),
              ts.factory.createImportSpecifier(
                false,
                undefined,
                ts.factory.createIdentifier('Insertable')
              ),
              ts.factory.createImportSpecifier(
                false,
                undefined,
                ts.factory.createIdentifier('Updateable')
              ),
            ])
          ),
          ts.factory.createStringLiteral('kysely'),
          undefined
        ),
        ts.factory.createImportDeclaration(
          undefined,
          ts.factory.createImportClause(
            false,
            undefined,
            ts.factory.createNamedImports([
              ts.factory.createImportSpecifier(
                false,
                undefined,
                ts.factory.createIdentifier(type)
              ),
            ])
          ),
          ts.factory.createStringLiteral(
            '../../datastore/kysely.database.types'
          ),
          undefined
        ),
        ts.factory.createIdentifier('\n'),
        ts.factory.createTypeAliasDeclaration(
          [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
          ts.factory.createIdentifier(
            `${capitalizeFirstLetter(camelCase(type))}`
          ),
          undefined,
          ts.factory.createTypeReferenceNode(
            ts.factory.createIdentifier('Selectable'),
            [
              ts.factory.createTypeReferenceNode(
                ts.factory.createIdentifier(type),
                undefined
              ),
            ]
          )
        ),
        ts.factory.createTypeAliasDeclaration(
          [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
          ts.factory.createIdentifier(
            `New${capitalizeFirstLetter(camelCase(type))}`
          ),
          undefined,
          ts.factory.createTypeReferenceNode(
            ts.factory.createIdentifier('Insertable'),
            [
              ts.factory.createTypeReferenceNode(
                ts.factory.createIdentifier(type),
                undefined
              ),
            ]
          )
        ),
        ts.factory.createTypeAliasDeclaration(
          [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
          ts.factory.createIdentifier(
            `Update${capitalizeFirstLetter(camelCase(type))}`
          ),
          undefined,
          ts.factory.createTypeReferenceNode(
            ts.factory.createIdentifier('Updateable'),
            [
              ts.factory.createTypeReferenceNode(
                ts.factory.createIdentifier(type),
                undefined
              ),
            ]
          )
        ),
        ts.factory.createIdentifier('\n'),
        ts.factory.createTypeAliasDeclaration(
          [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
          ts.factory.createIdentifier('InsertTypes'),
          undefined,
          ts.factory.createUnionTypeNode([
            ts.factory.createTypeReferenceNode(
              ts.factory.createIdentifier(
                `New${capitalizeFirstLetter(camelCase(type))}`
              ),
              undefined
            ),
            ts.factory.createTypeReferenceNode(
              ts.factory.createIdentifier(
                `Update${capitalizeFirstLetter(camelCase(type))}`
              ),
              undefined
            ),
          ])
        ),
      ],
      ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
      ts.NodeFlags.None
    )

    const result = printer.printNode(ts.EmitHint.Unspecified, source, file)
    await fs.writeFile(file.fileName, `${banner}\n${result}`)
  }

  /** visit nodes finding exported classes */
  function visit(node) {
    // Only consider exported nodes
    if (!isNodeExported(node)) {
      return
    }

    if (
      ts.isTypeAliasDeclaration(node) &&
      node.name &&
      node.name.escapedText === 'DB'
    ) {
      for (const member of node.type.members) {
        if (!ts.isPropertySignature(member)) break

        types.push(member.type.typeName.escapedText)
      }
    }
  }

  /** True if this is visible outside this file, false otherwise */
  function isNodeExported(node) {
    return (
      (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0 ||
      (!!node.parent && node.parent.kind === ts.SyntaxKind.SourceFile)
    )
  }
}

async function handleAPISchema(dir) {
  const files = (await fs.readdir(dir, { withFileTypes: true }))
    .filter((item) => !item.isDirectory())
    .map((item) => path.join(dir, item.name))

  const interfacesDir = path.join(process.cwd(), './src/interfaces/api')
  const jsonSchemaDir = path.join(process.cwd(), './src/schemas/json')

  try {
    await fs.mkdir(interfacesDir)
  } catch (err) {
    console.log('API interface already generated, will regenerate')
  }

  // For the JSON schema just delete the entire directory and rebuild
  try {
    await fs.mkdir(jsonSchemaDir)
  } catch (err) {
    await fs.rm(jsonSchemaDir, { force: true, recursive: true })
    await fs.mkdir(jsonSchemaDir, { recursive: true })
  }

  // We should clean up after ourselves and delete any older files no longer used
  const outputs = []
  for (const file of files) {
    console.log('Bundling %s', file)

    // JSON files so just require them for now
    const openAPI = require(file)
    openAPI.openapi = '3.1.0'

    // Bellow is used to fix references and dereference them, this
    // will help a lot, since we don't have any circular references
    // this is safe (I hope lol)
    const { bundleFromString, createConfig } = require('@redocly/openapi-core')
    const config = await createConfig({})

    const bundleResults = await bundleFromString({
      source: JSON.stringify(openAPI),
      // optionally pass path to the file for resolving $refs and proper error locations
      // absoluteRef: file,
      config,
    })

    const schemas = Object.entries(
      bundleResults.bundle.parsed.components.schemas
    ).map(([key, value]) => ({
      $id: key,
      additionalProperties: false,
      ...value,
    }))

    const complete = bundleOpenAPIAsJSONSchema(schemas, file)
    for (const schema of complete) {
      const ts = await require('json-schema-to-typescript').compile(
        schema,
        schema.title,
        { cwd: dir, bannerComment: banner }
      )
      await fs.writeFile(
        path.join(interfacesDir, `${schema.$id}.interface.ts`),
        ts
      )
      outputs.push(schema.$id)
    }
  }

  await removeAllExcept(interfacesDir, outputs)

  for (const file of outputs) {
    // console.error(path.join(interfacesDir, file), )
    console.log("Creating JSONSchema for '%s'", path.join(interfacesDir, file))
    const type = 'JSON' + capitalizeFirstLetter(camelCase(file))
    try {
      const buffer = require('child_process').execSync(
        `npx typescript-json-schema --skipLibCheck --required './${file}.interface.ts' '${type}'`,
        {
          cwd: interfacesDir,
        }
      )

      await fs.writeFile(
        path.join(jsonSchemaDir, `${file}.schema.json`),
        buffer.toString()
      )
    } catch (err) {
      console.error(err)
      return Promise.reject(err)
    }
  }
}

function camelCase(str, { upperCase = false } = {}) {
  if (str.length === 0) {
    return str
  }

  if (upperCase && isAllUpperCaseSnakeCase(str)) {
    // Only convert to lower case if the string is all upper
    // case snake_case. This allows camelCase strings to go
    // through without changing.
    str = str.toLowerCase()
  }

  let out = str[0]

  for (let i = 1, l = str.length; i < l; ++i) {
    const char = str[i]
    const prevChar = str[i - 1]

    if (char !== '_') {
      if (prevChar === '_') {
        out += char.toUpperCase()
      } else {
        out += char
      }
    }
  }

  return out
}

function isAllUpperCaseSnakeCase(str) {
  for (let i = 1, l = str.length; i < l; ++i) {
    const char = str[i]

    if (char !== '_' && char !== char.toUpperCase()) {
      return false
    }
  }

  return true
}

function capitalizeFirstLetter([first = '', ...rest], locale = 'en') {
  return [first.toLocaleUpperCase(locale), ...rest].join('')
}

function bundleOpenAPIAsJSONSchema(schemas, file) {
  const matcher = new Map([])

  return schemas
    .map((el, _, arr) => fixReferencePaths(el, arr, matcher))
    .map((el, _, arr) => {
      const topLevelDefs = checkIfKeyIsInValue(matcher)
      if (!topLevelDefs.includes(el.$id)) return null

      const children = matcher.get(el.$id)

      return {
        ...el,
        $defs: arr
          .filter((el) => children.includes(el.$id))
          .reduce(
            (prev, curr) => ({
              ...prev,
              [curr.$id]: curr,
            }),
            {}
          ),
      }
    })
    .filter((el) => !!el)
}

function fixReferencePaths(schema, schemas, matched = new Map([])) {
  matched.set(schema.$id, [])

  const parsed = JSON.parse(
    JSON.stringify(schema).replace(
      /#\/components\/schemas\/(?<ref>[a-z_]*)/g,
      function (match) {
        const { ref } = [...arguments].pop()

        if (schemas.findIndex((value) => value.$id === ref) === -1) return match

        if (ref === schema.$id) return '#'

        matched.get(schema.$id).push(ref)
        return `#/$defs/${ref}`
      }
    )
  )

  return {
    title: 'JSON' + capitalizeFirstLetter(camelCase(schema.$id)),
    ...addTSType(parsed),
  }
}

// Okay so this isnt't the best but since we can do this, might as well for now
function addTSType(schema) {
  if (!schema.properties) return schema

  for (const [_, property] of Object.entries(schema.properties)) {
    if (
      Array.isArray(property.type)
        ? property.type.includes('string')
        : property.type === 'string'
    ) {
      if (property.format === 'date' || property.format === 'date-time') {
        property['tsType'] = 'Date'
      }
    }
  }
  return schema
}

function checkIfKeyIsInValue(map = new Map([])) {
  const topLevelDefs = []

  const v = Array.from(map.values())
  const values = new Set(v.length > 0 ? v.flat() : v)

  for (const key of map.keys()) {
    if (!values.has(key)) topLevelDefs.push(key)
  }
  return topLevelDefs
}

/**
 * @param {string} dir
 * @param {string[]} files
 * @param {string} suffix
 * */
async function removeAllExcept(dir, files, suffix = '.interface.ts') {
  const _ = (await fs.readdir(dir, { withFileTypes: true }))
    .filter((el) => !files.includes(path.basename(el.name, suffix)))
    .map((el) => path.join(dir, el.name))

  for (const string of _) {
    try {
      await fs.rm(string)
    } catch (err) {
      console.error(err)
    }
  }
}
